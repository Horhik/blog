<h1 id="bonfire-graphql-guide">Bonfire GraphQL Guide <a class="direct-link" href="#bonfire-graphql-guide">#</a></h1>
<h2 id="graphql-introduction">GraphQL Introduction <a class="direct-link" href="#graphql-introduction">#</a></h2>
<p>Go to <a href="http://your-app-url/api/">http://your-app-url/api/</a> to start playing with the GraphQL API. The GraphiQL UI should autocomplete types, queries and mutations for you, and you can also explore the schema there.</p>
<p>Let's start with a simple GraphQL thoeretical query:</p>
<pre class="language-graphql"><code class="language-graphql"><span class="token keyword">query</span> <span class="token punctuation">{</span><br>  greetings<span class="token punctuation">(</span><span class="token attr-name">limit</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    greeting<br>    to <span class="token punctuation">{</span><br>      name<br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>Let's break this apart:</p>
<ul>
<li><code>query {}</code> is how you retrieve information from GraphQL.</li>
<li><code>greetings</code> is a <code>field</code> within the query.</li>
<li><code>greetings</code> takes a <code>limit</code> argument, a positive integer.</li>
<li><code>greetings</code> has two fields, <code>greeting</code> and <code>to</code>.</li>
<li><code>to</code> has one <code>field</code>, <code>name</code>.</li>
</ul>
<p>This query is asking for a list of (up to) 10 greetings and the people<br>
they are for. Notice that the result of both <code>greetings</code> and <code>to</code> are<br>
map/object structures with their own fields and that if the type has<br>
multiple fields, we can select more than one field.</p>
<p>Here is some possible data we could get returned</p>
<pre class="language-elixir"><code class="language-elixir"><span class="token punctuation">%</span><span class="token punctuation">{</span><span class="token attr-name">greetings:</span> <span class="token punctuation">[</span><br>    <span class="token punctuation">%</span><span class="token punctuation">{</span><span class="token attr-name">greeting:</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token attr-name">to:</span> <span class="token punctuation">%</span><span class="token punctuation">{</span> <span class="token attr-name">name:</span> <span class="token string">"dear reader"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment"># english</span><br>    <span class="token punctuation">%</span><span class="token punctuation">{</span><span class="token attr-name">greeting:</span> <span class="token string">"hallo"</span><span class="token punctuation">,</span> <span class="token attr-name">to:</span> <span class="token punctuation">%</span><span class="token punctuation">{</span> <span class="token attr-name">name:</span> <span class="token string">"beste lezer"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment"># dutch</span><br>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>
<p>Where is the magic? Typically an object type will reside in its own<br>
table in the database, so this query is actually querying two tables<br>
in one go. In fact, given a supporting schema, you can nest queries<br>
arbitrarily and the backend will figure out how to run them.</p>
<p>The fact that you can represent arbitrarily complex queries puts quite<br>
a lot of pressure on the backend to make it all efficient. This is<br>
still a work in progress at this time.</p>
<h2 id="absinthe-introduction">Absinthe Introduction <a class="direct-link" href="#absinthe-introduction">#</a></h2>
<p>Every <code>field</code> is filled by a resolver. Let's take our existing query<br>
and define a schema for it in Absinthe's query DSL:</p>
<pre class="language-elixir"><code class="language-elixir"><span class="token keyword">defmodule</span> MyApp<span class="token punctuation">.</span>Schema <span class="token keyword">do</span><br>  <span class="token comment"># the schema macro language</span><br>  <span class="token keyword">use</span> Absinthe<span class="token punctuation">.</span>Schema<span class="token punctuation">.</span>Notation<br>  <span class="token comment"># where we will actually resolve the fields</span><br>  <span class="token keyword">alias</span> MyApp<span class="token punctuation">.</span>Resolver<br><br>  <span class="token comment"># Our user object is pretty simple, just a name</span><br>  object <span class="token atom symbol">:user</span> <span class="token keyword">do</span><br>    field <span class="token atom symbol">:name</span><span class="token punctuation">,</span> non_null<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span><br>  <span class="token keyword">end</span><br><br>  <span class="token comment"># This one is slightly more complicated, we have that nested `to`</span><br>  object <span class="token atom symbol">:greeting</span> <span class="token keyword">do</span><br>    <span class="token comment"># the easy one</span><br>    field <span class="token atom symbol">:greeting</span><span class="token punctuation">,</span> non_null<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span><br>    <span class="token comment"># the hard one. `edge` is the term for when we cross an object boundary.</span><br>    field <span class="token atom symbol">:to</span><span class="token punctuation">,</span> non_null<span class="token punctuation">(</span><span class="token atom symbol">:user</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">do:</span> resolve<span class="token punctuation">(</span><span class="token capture function">&amp;Resolver.to_edge/3</span><span class="token punctuation">)</span><br>  <span class="token keyword">end</span><br><br>  <span class="token comment"># something to put our top level queries in, because they're just fields too!</span><br>  object <span class="token atom symbol">:queries</span> <span class="token keyword">do</span><br>    field <span class="token atom symbol">:greetings</span><span class="token punctuation">,</span> non_null<span class="token punctuation">(</span>list_of<span class="token punctuation">(</span>non_null<span class="token punctuation">(</span><span class="token atom symbol">:string</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">do</span><br>      arg <span class="token atom symbol">:limit</span><span class="token punctuation">,</span> <span class="token atom symbol">:integer</span> <span class="token comment"># optional</span><br>      resolve <span class="token capture function">&amp;Resolver.greetings/2</span> <span class="token comment"># we need to manually process this one</span><br>    <span class="token keyword">end</span><br>  <span class="token keyword">end</span><br><br><span class="token keyword">end</span></code></pre>
<p>There are a couple of interesting things about this:</p>
<ul>
<li>Sprinklings of <code>not_null</code> to require that values be present (if you<br>
don't return them, absinthe will get upset).</li>
<li>Only two fields have explicit resolvers. Anything else will default<br>
to a map key lookup (which is more often than not what you want).</li>
<li><code>greeting.to_edge</code> has a <code>/3</code> resolver and <code>queries.greetings</code> a<br>
<code>/2</code> resolver.</li>
</ul>
<p>To understand the last one (and partially the middle one), we must<br>
understand how resolution works and what a parent is. The best way of<br>
doing that is probably to look at the resolver code:</p>
<pre class="language-elixir"><code class="language-elixir"><span class="token keyword">defmodule</span> MyApp<span class="token punctuation">.</span>Resolver <span class="token keyword">do</span><br><br>  <span class="token comment"># For purposes of this, we will just fake the data out</span><br>  <span class="token keyword">defp</span> greetings_data<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">do</span><br>    <span class="token punctuation">[</span> <span class="token punctuation">%</span><span class="token punctuation">{</span><span class="token attr-name">greeting:</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token attr-name">to:</span> <span class="token punctuation">%</span><span class="token punctuation">{</span> <span class="token attr-name">name:</span> <span class="token string">"dear reader"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment"># english</span><br>      <span class="token punctuation">%</span><span class="token punctuation">{</span><span class="token attr-name">greeting:</span> <span class="token string">"hallo"</span><span class="token punctuation">,</span> <span class="token attr-name">to:</span> <span class="token punctuation">%</span><span class="token punctuation">{</span> <span class="token attr-name">name:</span> <span class="token string">"beste lezer"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment"># dutch</span><br>    <span class="token punctuation">]</span><br>  <span class="token keyword">end</span><br><br>  <span class="token comment"># the /2 resolver takes only arguments (which in this case is just limit)</span><br>  <span class="token comment"># and an info (which we'll explain later)</span><br>  <span class="token keyword">def</span> greetings<span class="token punctuation">(</span><span class="token punctuation">%</span><span class="token punctuation">{</span><span class="token attr-name">limit:</span> limit<span class="token punctuation">}</span><span class="token punctuation">,</span> _info<span class="token punctuation">)</span> <span class="token keyword">when</span> is_integer<span class="token punctuation">(</span>limit<span class="token punctuation">)</span> <span class="token keyword">and</span> limit <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">do</span><br>    <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> Enum<span class="token punctuation">.</span>take<span class="token punctuation">(</span>greetings_data<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> limit<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment"># absinthe expects an ok/error tuple</span><br>  <span class="token keyword">end</span><br>  <span class="token keyword">def</span> greetings<span class="token punctuation">(</span>_args<span class="token punctuation">,</span> _info<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">do:</span> <span class="token punctuation">{</span><span class="token atom symbol">:ok</span><span class="token punctuation">,</span> greetings_data<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token comment"># no limit</span><br><br>  <span class="token comment"># the /3 resolver takes an additional parent argument in first position.</span><br>  <span class="token comment"># `parent` here will be the `greeting` we are resolving `to` for.</span><br>  <span class="token keyword">def</span> to_edge<span class="token punctuation">(</span>parent<span class="token punctuation">,</span> args<span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">do:</span> Map<span class="token punctuation">.</span>get<span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token atom symbol">:to</span><span class="token punctuation">)</span><br><br><span class="token keyword">end</span></code></pre>
<p>The keen-eyed amongst you may have noticed I said the default resolver<br>
is a map lookup and our <code>to_edge/3</code> is a map lookup too, so<br>
technically we didn't need to write it. But then you wouldn't have an<br>
example of a <code>/3</code> resolver! In most of the app, these will be querying<br>
from the database, not looking up in a constant.</p>
<p>So for every field, a resolver function is run. It defaults to a map<br>
lookup, but you can override it with <code>resolve/1</code>. It may or may not<br>
have arguments. And all absinthe resolvers return an ok/error tuple.</p>
<h2 id="patterns">Patterns <a class="direct-link" href="#patterns">#</a></h2>
